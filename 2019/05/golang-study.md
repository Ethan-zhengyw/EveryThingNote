# Golang学习

## exercise code repository: https://github.com/Ethan-zhengyw/golang-exercise-code

## 1.1 概览

### Go 语言项目

#### Docker

#### Kubernetes

#### Caddy（网站服务器）

#### CockroachDB

### Go语言的设计初衷

#### 针对其它语言的痛点进行设计

#### 并加入并发编程

#### 为大数据，微服务，并发而生的通用编程语言

### Go语言与转型

#### 项目转型首选语言

#### 软件工程师转型、添加技术栈的首选语言

### Go语言的特点

#### 1. 没有“对象”，没有继承多态，没有泛型，没有try/catch

#### 2. 有接口，函数式编程，CSP并发模型（goroutine + channel）

#### 重点：怎么利用Go语言实现其它语言利用1中所描述的特性能够实现的功能呢？

### Go语言课程

#### 语法 + 例子

##### 变量、选择、循环、指针、数组、容器

#### 面向接口

##### 结构体

##### duck typing

##### 组合思想

#### 函数式编程

##### 闭包

#### 工程化

##### 资源管理

##### 错误处理

##### 性能调优

#### 并发编程

##### goroutine + channel

##### 调度器

#### 项目

##### 爬虫项目

###### 单任务版

###### 并发版

###### 分布式

## 1.2 安装环境

### ...

## 2.1 变量定义

### 定义方式

#### var [变量名] [变量类型]  

#### var [变量名] [变量类型]  = [变量初始值]

#### [变量名] := [变量初始值]

#### var尽量不用，用:=

##### 函数外必须使用var，作用域是包内的

### 变量一旦定义就必须使用

## 2.2 内建变量类型

### 基本类型和初始值

#### bool, string

#### (u)int,  uintptr

##### 长度跟随操作系统

#### (u)int(8/16/32/64)

##### 固定长度整数

#### byte，rune

##### rune长度为32位

###### utf8中很多字符都是3字节的，因此采用4字节的int32作为rune

###### go语言没有char，rune就是go语言中的char

#### float32, float64

#### complex64, complex128

### 强制类型转换

#### 不存在隐式类型转换

## 2.3 常量定义

### const关键字

### iota自增值种子

## 2.4 条件语句

### if

#### 条件里可以定义变量

### switch

#### switch不需要break

### 条件不需要括号

## 2.5 循环

### for

#### 死循环非常好写，在go语言中经常用到死循环

#### 条件不需要括号

#### 括号换行需要打逗号

## 2.6 函数

### 函数作为参数

### 返回值类型放在后面

### 可返回多个值

### 可变参数列表

#### func sum(numbers ...int) int

### 值传递 vs 引用传递

#### C/C++既可以值传递又可以引用传递

#### Python/Java绝大多数都是引用传递，除了少部分的自建类型外

#### Go语言只有值传递

##### 性能就下降了？/通过指针解决

## 2.7 指针

### 指针类型 *int

#### var a int = 2
var pa *int = &a
*pa = 3

### 指针不能运算

## 3.1 数组

### var arr1 [3]int
	arr2 := [3]int{1, 2, 3}
	arr3 := [...]int{1, 2, 3, 4}
var grid [4][5]int

### 利用range关键子获得下标与值

### 数组是值类型

#### 函数参数定义使用数组需要指定数组长度，否则类型无法匹配上

#### 参数传递过程会拷贝数组

#### 可以通过传指针的方式达到call by ref的效果

### go语言一般不使用数组，使用切片

## 3.2 切片

### 切片是数组的一个视图，修改视图会同时修改原始数组，即使通过函数传递切片

### 左闭右开

### 支持对切片进行切片（reslice）

### 切片的下标超过切片的最大长度，但在原始数组的capacity内的话能够扩展取到

#### 只能向后扩展，不能向前扩展

### slice == (ptr, len, cap)

## 3.3 切片的操作

### append(slice, N)

#### 删除元素通过切片append操作实现

##### apend(s1[:3], s1[4:]...)

### pop from front/back 通过切片下标控制

### 添加元素超过cap，系统会重新分配更大的底层数组

### 切片变量的初始值为nil

#### var s []int

### 切片是一个数组的视图，它的容量能够自动扩展，类似STL中的vector

## 3.4 Map

### 类型定义 map[K]V

### 遍历方法同数组，使用arrange关键字

### map是一个hashmap，内部数据存储是无序的

#### 如果需要有序，需要把key取出来放到一个slice中进行排序

### key不存在时，使用该key查询得到对应类型的初始值，不会报错

### 判断值是否存在 if val1, ok = map["key1"]; ok {} else {}

### 删除元素

#### delete(m, key)

### map的key

#### map使用哈希表，必须可以比较相等

#### 除了slice，map，function的内建类型都可以作为key

#### 自定义类型（Struct）不包含slice，map，function也可作为key

## 3.5 Map例题，寻找最长不含有重复字符的字串

## 3.6 字符和字符串处理

### 类型转换

#### 使用utf8.RuneCountInString获得字符数量，支持中文

#### 使用len获得字节长度

#### 使用[]byte获得字节

#### 使用[]rune获得通用的字符数组，每个字符占4个字节，系统会新开辟一个空间来存放该数组，能够无差别地处理中英文

### 库函数

#### Fields, Split, Join

#### Contains, Index

#### ToLower, ToUpper

#### Trim, TrimRight, TrimLeft

## 4.1 结构体和方法

### go语言仅支持封装，不支持继承和多态

### 自定义工厂函数进行初始化

#### go语言局部变量也可以将其地址返回给上层函数使用

##### 局部变量创建在堆上还是栈上由编译器决定

### 函数定义能够指定接收者

#### 定义新方法，同时指定结构体接收者，达到定义结构体方法的效果

#### 值接收者 vs 指针接收者

##### 要改变内容必须使用指针接收者

##### 结构体过大也考虑使用指针接收者

##### 保持代码一致性

### 空也能调用方法

## 4.2 包和封装

### 封装（针对包）

#### CamelCase

#### 首字母大写表示public

#### 首字母小些表示private

### 包

#### 每个目录一个包

##### 目录下的所有文件都属于同一个包，子目录中的文件除外

#### 每个目录一个main

#### 为结构定义的方法必须放在同一个包内

##### 但是可以是不同的文件

### 命名技巧

#### 包内的结构体不需要重复包名，例如tree包中的TreeNode直接叫Node即可

## 4.3 扩展已有类型

### 使用组合

#### 定义一个结构体，结构体内使用已有类型

### 定义别名

#### Queue基于[]int实现（将[]int重命名为Queue）

##### type Queue []int

## 4.4 GOPATH环境变量

### 默认在~/go

### 官方推荐：所有项目和第三方库都放在同一个GOPATH下

### 也可以将每个项目放在不同的GOPATH

### go imports工具（保存时自动修正/格式化import数据）

#### go get -v github.com/gpmgo/gopm

#### gopm get -g -v -u golang.org/x/tools/cmd/goimports

#### go install golang.org/x/tools/cmd/goimports

### gopath目录结构

#### src

##### 源码

#### pkg

##### 编译中间过程文件

#### bin

##### 可执行文件

## 5.1 duck typing的概念

### 许多语言都支持duck typing

### 大黄鸭是不是一只鸭子

#### 像鸭子走路，像鸭子叫，长得像鸭子，那么就是鸭子

#### 描述事物的外部行为而非内部结构

#### 一个事物属不属于某一类型，在不同的使用者看来可能可能有不同的结果

### python的duck typing

#### 运行时检查

### C++中的duck typing

#### 使用template

#### 编译时检查

### Java中类似duck typing

#### 类型备注

#### 不支持多个接口

## 5.2 接口的定义与实现

### 接口由使用者定义

### 接口的实现者在实现接口的过程中不会关注接口的类型，只关注接口中的具体方法

#### 分为两个步骤

##### 1. 定义一个类型

##### 2. 定义接口中指定的方法，该方法的接收者为定义的类型

## 5.3 接口的值类型

### 接口变量中有实现者的类型，实现者的值或指针

### 获取接口类型

#### 使用switch语句获取真实值

##### switch a := t.(type)

#### 使用type assertion

##### tt, ok := t.(certain_type)

#### 任何类型 interface{}

## 5.4 接口的组合

### 接口能够进行组合，组合后的接口具有所有被组合的接口的方法

## 5.5 常用系统接口

### Stringer in fmt/print.go

#### func (xxx xxx) String() string { return "xxx" }

### 读写抽象（文件/string/byte数组）

#### Reader in io/io.go

##### Read(p []byte) (n int, err error)

#### Writer in io/io.go

##### Write(p []byte) (n int, err error)

## 6.1 函数式编程

### 匿名函数

#### 常规的函数定义——需要指定函数的名称，函数的内容在编译时就确定下来

#### 匿名函数——通过定义一个函数类型的变量，给该变量进行赋值时定义一个“匿名函数”，只有函数参数、函数体，没有名字；能够在程序运行时动态地改变该“函数类型变量”的执行内容

#### 匿名函数与常规函数的根本区别

##### 匿名函数不是在包级别上进行定义的，它在程序运行过程中被临时定义，用完即忘，或者被赋给某个变量待用

### 函数与闭包

#### 函数返回一个累加器？

### 函数式编程 vs 函数指针

#### 函数是一等公民：参数、变量、返回值都可以是函数

#### 高阶函数

#### 函数 --> 闭包

##### 函数体

##### 局部变量（传递进入函数的参数、在函数体内定义的变量）

##### 自由变量（树结构的连接变量）（在 函数体外定义的变量/函数所处的环境）

##### 函数返回值为“闭包”——包括函数体/局部变量/自由变量

##### 所以什么是闭包呢！？

###### 闭包是一种特殊的匿名函数，它特殊在它引用了在自己这个函数之外定义的变量

###### 因为存在在这特殊的引用关系，所以“外部参数”不必作为参数传递给闭包函数，闭包函数也能访问到“外部参数”

####### 与“全局变量和常规函数”的关系类似

##### 为什么需要闭包呢？

###### 1. 数据隔离与持久化

####### 数据隔离

######## 避免使用全局变量或者函数参数，使得数据仅对闭包可见

####### 数据持久化（运行时的、函数退出后依然存在）

######## 变量作为闭包的自由变量，被闭包函数引用，会持久化储存

###### 2. 装饰函数和创建中间件

####### 装饰函数

######## 函数是一等公民，因此函数能够作为函数的参数使用

######## http.HandleFunc('/xxx', func(w http.ResponseWriter, r *http.Request) {} )

####### 创建中间件

######## 什么是中间件

######### 中间件(middleware)是基础软件的一大类，属于可复用软件的范畴。

######### 中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。

######### web领域

########## 开发web应用时，可复用的函数

########## 计时器装饰器 —— 接受原始handler，返回一个匿名函数，也就是闭包

###### 3. 访问原本访问不到的数据（在数据隔离与持久化中提到过，但因为非常游泳，所以值得单独拿出来讲）

####### A closure can also be used to wrap data inside of a function that otherwise wouldn’t typically have access to that data.

####### 给http handler添加原本访问不到的参数——例如：数据库

######## 函数的局部变量/函数的参数均可被函数内返回的匿名函数访问到

######## 数据库对象/参数 作为 闭包函数的自由变量

###### 4. 排序与搜索库

####### 不传递数组/切片给排序函数，而是传递一个匿名函数闭包给排序函数，闭包能够访问到待排序的对象

###### 5. 推迟执行函数

####### 类似javascript中的callback？

######## 嵌套的callback函数调用

####### go语言中通过goroutine和closure实现类似javascrip中的callback功能，可读性更强

######## 优点

######### 执行顺序清晰，可读性强

######### 在go语句块中，各个语句并发执行？（执行顺序清晰怎么还是并发执行的？）

######### 不必为函数另外实现一个异步的版本——go语言帮我们完成，会自动等待result？

### “正统”函数式编程

#### 不可变性：不能有状态，只有常量和函数

#### 函数只能有一个参数

### 其他语言的闭包

#### python中的闭包

##### 自由变量需要使用nonlocal关键字声明

##### 可以使用__closure__查看闭包内容

##### 函数需要定义名称

#### c++中的闭包

##### auto/mutable/[=]关键字

#### java中的闭包

##### 使用Function接口和Lambda表达式创建函数对象

## 6.2 函数式编程例一

### 斐波纳切数列函数生成器

### 斐波纳切数列生成器Reader

#### 返回值——函数——定义为自定义类型

##### type myFuncName func() funcReturnType

#### 为函数实现Read接口

##### func (mf myFuncName) Read(p []byte) (n int, err error) {}

###### 利用strings.NewReader(xxx).Read(p)帮助构造Reader

## 6.3 函数式编程例二

### 使用函数来遍历二叉树

## 999 我的疑问

### 1. Go 语言针对其它语言的哪些痛点进行了哪些设计？

#### Java/C++等面向对象语言支持封装继承和多态，使用起来相对复杂麻烦，go语言面向接口，没有class，只有struct仅支持封装，不支持继承和多态

#### 使用rune类型支持字符串处理unicode

#### 对象分配的位置，由编译器决定、优化

#### nil也可以调用方法

#### 接口由使用者定义

### 2. 其它语言对的发编程是怎样的？Go语言的并发编程的相比于其它语言有什么异同？

### 3. 为什么说Go语言是为大数据，微服务，并发而生的通用编程语言？

### 4. 为什么说Go语言是项目转型的首选语言？

### 5. 怎么利用Go语言实现其它语言利用“对象”，继承多态，泛型，try/catch等特性能够实现的功能呢？

### 6. 为什么Go语言变量定义变量名要放在变量类型之前？

### 7. 求(a^2 + b^2)^0.5，转出来小了1怎么处理

### 8. 为什么go语言中经常用到死循环？

#### goroutine 死循环 互相通信
